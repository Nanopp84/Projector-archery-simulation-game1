<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D IPSC射擊模擬器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        .ui-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            z-index: 50;
        }
        
        .top-ui {
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .bottom-ui {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }
        
        .hit-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff00;
            pointer-events: none;
            z-index: 60;
            animation: hitFade 1s ease-out forwards;
        }
        
        @keyframes hitFade {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1.5); }
            100% { opacity: 0; transform: translate(-50%, -70%) scale(1); }
        }
        
        .controls-info {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }
        
        /* 準備提示文字樣式 */
        .ready-notice {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 0 0 15px #ffd700;
            pointer-events: none;
            z-index: 70;
            opacity: 0;
            animation: fadeInOut 3s ease-out forwards;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
        
        @media (max-width: 768px) {
            .top-ui {
                flex-direction: column;
                gap: 10px;
            }
            
            .controls-info {
                font-size: 10px;
            }
            
            .ready-notice {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Top UI -->
        <div class="ui-panel top-ui">
            <div class="flex space-x-6">
                <div class="text-center">
                    <div class="text-sm text-gray-300">時間</div>
                    <div id="timer" class="text-xl font-bold text-green-400">0.00s</div>
                </div>
                <div class="text-center">
                    <div class="text-sm text-gray-300">得分</div>
                    <div id="score" class="text-xl font-bold text-yellow-400">0</div>
                </div>
                <div class="text-center">
                    <div class="text-sm text-gray-300">命中</div>
                    <div id="hits" class="text-xl font-bold text-blue-400">0/10</div>
                </div>
                <div class="text-center">
                    <div class="text-sm text-gray-300">位置</div>
                    <div id="position" class="text-lg font-bold text-purple-400">A</div>
                </div>
            </div>
            
            <div class="flex space-x-3">
                <button id="startBtn" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white font-bold rounded text-base">
                    開始
                </button>
                <button id="resetBtn" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white font-bold rounded text-base">
                    重置
                </button>
            </div>
        </div>
    </div>

    <script>
        class IPSC3DGame {
            constructor() {
                this.gameContainer = document.getElementById('gameContainer');
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                
                // 遊戲狀態
                this.gameStarted = false;
                this.gameEnded = false;
                this.startTime = 0;
                this.currentTime = 0;
                this.score = 0;
                this.hits = 0;
                this.playerPosition = 'A';
                this.isMoving = false;
                this.isPreparing = false; // 新增：準備階段標誌（避免準備期間誤操作）
                
                // 移動相關
                this.keys = {};
                this.mouseX = 0;
                this.mouseY = 0;
                this.isPointerLocked = false;
                
                // 玩家位置 - 沿X軸分佈，Z軸固定在較前位置
                this.positions = {
                    A: { x: -18, y: 3.0, z: 5 },
                    B: { x: -6, y: 3.0, z: 5 },
                    C: { x: 6, y: 3.0, z: 5 },
                    D: { x: 18, y: 3.0, z: 5 },
                    E: { x: 30, y: 3.0, z: 5 }
                };
                
                // 靶位
                this.targets = [];
                this.targetMeshes = [];

                // -------------- 核心修改1：初始化音頻物件 --------------
                this.initAudio();
                
                this.initRenderer();
                this.initScene();
                this.initLights();
                this.initTargets();
                this.initEventListeners();
                this.initControls();
                this.gameLoop();
            }

            // -------------- 新增方法：初始化音頻 --------------
            initAudio() {
                // 準備音頻（shootoff-are-you-ready.WAV）- 請確保音頻檔案路徑正確
                this.audioReady = new Audio('shootoff-are-you-ready.WAV');
                // 提示音（beep.WAV）- 請確保音頻檔案路徑正確
                this.audioBeep = new Audio('beep.WAV');
                
                // 可選：設定音頻音量（0~1）
                this.audioReady.volume = 0.8;
                this.audioBeep.volume = 1.0;
            }
            
            // 繪製更接近圖片的IPSC靶形
            drawIPSCTarget(ctx, centerX, centerY, size) {
                const scale = size / 100;
                
                // 外八角形（深棕色）
                ctx.fillStyle = '#8B4513';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                const outerPoints = [
                    [centerX - 50*scale, centerY - 20*scale],
                    [centerX - 20*scale, centerY - 50*scale],
                    [centerX + 20*scale, centerY - 50*scale],
                    [centerX + 50*scale, centerY - 20*scale],
                    [centerX + 50*scale, centerY + 20*scale],
                    [centerX + 20*scale, centerY + 50*scale],
                    [centerX - 20*scale, centerY + 50*scale],
                    [centerX - 50*scale, centerY + 20*scale]
                ];
                ctx.moveTo(outerPoints[0][0], outerPoints[0][1]);
                for (let i = 1; i < outerPoints.length; i++) {
                    ctx.lineTo(outerPoints[i][0], outerPoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // 中間八角形（中棕色）
                ctx.fillStyle = '#CD853F';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const midPoints = [
                    [centerX - 35*scale, centerY - 15*scale],
                    [centerX - 15*scale, centerY - 35*scale],
                    [centerX + 15*scale, centerY - 35*scale],
                    [centerX + 35*scale, centerY - 15*scale],
                    [centerX + 35*scale, centerY + 15*scale],
                    [centerX + 15*scale, centerY + 35*scale],
                    [centerX - 15*scale, centerY + 35*scale],
                    [centerX - 35*scale, centerY + 15*scale]
                ];
                ctx.moveTo(midPoints[0][0], midPoints[0][1]);
                for (let i = 1; i < midPoints.length; i++) {
                    ctx.lineTo(midPoints[i][0], midPoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // 內八角形（淺棕色）
                ctx.fillStyle = '#DEB887';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const innerPoints = [
                    [centerX - 20*scale, centerY - 10*scale],
                    [centerX - 10*scale, centerY - 20*scale],
                    [centerX + 10*scale, centerY - 20*scale],
                    [centerX + 20*scale, centerY - 10*scale],
                    [centerX + 20*scale, centerY + 10*scale],
                    [centerX + 10*scale, centerY + 20*scale],
                    [centerX - 10*scale, centerY + 20*scale],
                    [centerX - 20*scale, centerY + 10*scale]
                ];
                ctx.moveTo(innerPoints[0][0], innerPoints[0][1]);
                for (let i = 1; i < innerPoints.length; i++) {
                    ctx.lineTo(innerPoints[i][0], innerPoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            initRenderer() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.gameContainer.appendChild(this.renderer.domElement);
            }
            
            initScene() {
                // 地面 - 擴大地面以適應區域
                const groundGeometry = new THREE.PlaneGeometry(100, 100);
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x4a5d23 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // 所有區域的射擊場標記
                const markerGeometry = new THREE.BoxGeometry(2, 0.1, 2);
                const markerColors = {
                    A: 0xff4444,
                    B: 0x4444ff,
                    C: 0x44ff44,
                    D: 0xffff44,
                    E: 0xff44ff
                };
                
                for (const zone in this.positions) {
                    const markerMaterial = new THREE.MeshLambertMaterial({ color: markerColors[zone] });
                    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                    marker.position.set(this.positions[zone].x, 0.05, this.positions[zone].z);
                    this.scene.add(marker);
                }
                
                // 增加更多障礙物以分隔區域
                this.createBarriers();
                
                // 設定初始相機位置
                this.setPlayerPosition('A');
            }
            
            createBarriers() {
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                
                // 左牆
                const leftWallGeometry = new THREE.BoxGeometry(1, 4, 40);
                const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
                leftWall.position.set(-35, 2, -10);
                leftWall.castShadow = true;
                this.scene.add(leftWall);
                
                // 右牆
                const rightWallGeometry = new THREE.BoxGeometry(1, 4, 40);
                const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
                rightWall.position.set(35, 2, -10);
                rightWall.castShadow = true;
                this.scene.add(rightWall);
                
                // 區域間分隔牆
                const dividerPositions = [-12, 0, 12, 24]; // A-B, B-C, C-D, D-E之間
                dividerPositions.forEach(pos => {
                    const dividerGeometry = new THREE.BoxGeometry(0.5, 3, 20);
                    const divider = new THREE.Mesh(dividerGeometry, wallMaterial);
                    divider.position.set(pos, 1.5, -10);
                    divider.castShadow = true;
                    this.scene.add(divider);
                });
            }
            
            initLights() {
                // 環境光
                const ambientLight = new THREE.AmbientLight(0x404040, 0.7);
                this.scene.add(ambientLight);
                
                // 主要平行光
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
                directionalLight.position.set(40, 60, 30);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.3;
                directionalLight.shadow.camera.far = 300;
                directionalLight.shadow.camera.left = -60;
                directionalLight.shadow.camera.right = 60;
                directionalLight.shadow.camera.top = 40;
                directionalLight.shadow.camera.bottom = -40;
                this.scene.add(directionalLight);
            }
            
            initTargets() {
                // 靶位位置 - 調整Z坐標使靶位更靠近玩家
                const targetPositions = [
                    // A區 - 玩家正前方
                    { id: 'A1', x: -18, y: 2, z: 1, distance: 1.0, zone: 'A' },
                    { id: 'A2', x: -20, y: 2.5, z: 2, distance: 1.1, zone: 'A' },
                    
                    // B區 - 玩家140度後方（精確計算）
                    { id: 'B1', x: -1, y: 1, z: 6, distance: 1.0, zone: 'B' },
                    { id: 'B2', x: -4, y: 1.5, z: 8, distance: 1.1, zone: 'B' },
                    
                    // C區 - 玩家正前方
                    { id: 'C1', x: 3, y: 2, z: 2, distance: 1.0, zone: 'C' },
                    { id: 'C2', x: 6, y: 2.5, z: -1, distance: 1.1, zone: 'C' },
                    
                    // D區 - 玩家正前方
                    { id: 'D1', x: 16, y: 2, z: 1.5, distance: 1.0, zone: 'D' },
                    { id: 'D2', x: 20, y: 1, z: 1, distance: 1.1, zone: 'D' },
                    
                    // E區 - 玩家正前方
                    { id: 'E1', x: 28, y: 2, z: 2.5, distance: 1.0, zone: 'E' },
                    { id: 'E2', x: 29.5, y: 2.5, z: 1.5, distance: 1.1, zone: 'E' }
                ];
                
                targetPositions.forEach((pos) => {
                    const targetGroup = new THREE.Group();
                    
                    // 建立自訂IPSC靶形
                    const targetCanvas = document.createElement('canvas');
                    targetCanvas.width = 256;
                    targetCanvas.height = 320;
                    const ctx = targetCanvas.getContext('2d');
                    
                    ctx.fillStyle = 'transparent';
                    ctx.fillRect(0, 0, 256, 320);
                    this.drawIPSCTarget(ctx, 128, 160, 110); // 調整大小參數以匹配圖片比例
                    
                    const targetTexture = new THREE.CanvasTexture(targetCanvas);
                    targetTexture.needsUpdate = true;
                    
                    // 靶面（plate）- 確保面朝玩家（Z軸正方向）
                    const scaleFactor = 1.3;
                    const plateGeometry = new THREE.PlaneGeometry(2 * scaleFactor, 2.5 * scaleFactor);
                    const plateMaterial = new THREE.MeshLambertMaterial({ 
                        map: targetTexture,
                        transparent: true,
                        alphaTest: 0.1
                    });
                    const plate = new THREE.Mesh(plateGeometry, plateMaterial);
                    plate.castShadow = true;
                    plate.position.set(0, 0, 0);
                    // 靶位面朝Z軸正方向（朝向玩家）
                    targetGroup.add(plate);
                    
                    // 靶架（木棍）
                    const standGeometry = new THREE.BoxGeometry(0.12, 2.2, 0.12);
                    const standMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const stand = new THREE.Mesh(standGeometry, standMaterial);
                    stand.position.set(0, -1.25, -0.1); 
                    targetGroup.add(stand);
                    
                    // 靶位標籤
                    const labelCanvas = document.createElement('canvas');
                    labelCanvas.width = 140;
                    labelCanvas.height = 70;
                    const labelCtx = labelCanvas.getContext('2d');
                    labelCtx.fillStyle = '#FFFFFF';
                    labelCtx.font = 'bold 36px Arial';
                    labelCtx.textAlign = 'center';
                    labelCtx.fillText(pos.id, 70, 45);
                    
                    const labelTexture = new THREE.CanvasTexture(labelCanvas);
                    const labelMaterial = new THREE.MeshLambertMaterial({ map: labelTexture });
                    const labelGeometry = new THREE.PlaneGeometry(0.9, 0.45);
                    const label = new THREE.Mesh(labelGeometry, labelMaterial);
                    label.position.set(0, -0.9, 0.05);
                    targetGroup.add(label);
                    
                    targetGroup.position.set(pos.x, pos.y, pos.z);
                    
                    // B區的靶位需要旋轉朝向玩家 - 僅調整B1靶順時針旋轉
                    if (pos.zone === 'B') {
                        // 計算B區靶位應該面向B區玩家位置的角度
                        const playerPosB = this.positions.B;
                        let angleToPlayer = Math.atan2(playerPosB.x - pos.x, playerPosB.z - pos.z);
                        
                        // 關鍵修改：B1靶額外順時針旋轉0.3弧度（約17度），數值可調整
                        if (pos.id === 'B1') {
                            angleToPlayer -= 0.5; // 減少y軸旋轉值 = 順時針旋轉
                        }
                        
                        targetGroup.rotation.y = angleToPlayer;
                    }
                    
                    this.scene.add(targetGroup);
                    
                    this.targets.push({
                        id: pos.id,
                        position: pos,
                        hit: false,
                        distance: pos.distance,
                        mesh: targetGroup,
                        plate: plate,
                        originalColor: 0xFFD700,
                        zone: pos.zone
                    });
                    
                    this.targetMeshes.push(plate);
                });
            }
            
            // 改進的IPSC八角形擊中偵測
            isValidHit(uv) {
                // 將UV坐標轉換為靶位畫布坐標
                const x = uv.x * 256;
                const y = (1 - uv.y) * 320; // 翻轉Y軸
                
                // 檢查是否在IPSC靶位的八角形區域內
                const centerX = 128;
                const centerY = 160;
                const scale = 110 / 100; // 與繪製時相同的比例
                
                // 計算相對於中心的坐標
                const dx = x - centerX;
                const dy = y - centerY;
                const absDx = Math.abs(dx);
                const absdy = Math.abs(dy);
                
                // 外層八角形的精確邊界偵測
                // 定義八角形的8個頂點（與繪製時相同）
                const outerPoints = [
                    [-50*scale, -20*scale], // 左上
                    [-20*scale, -50*scale], // 上左
                    [20*scale, -50*scale],  // 上右
                    [50*scale, -20*scale],  // 右上
                    [50*scale, 20*scale],   // 右下
                    [20*scale, 50*scale],   // 下右
                    [-20*scale, 50*scale],  // 下左
                    [-50*scale, 20*scale]   // 左下
                ];
                
                // 使用射線法偵測點是否在八角形內
                let inside = false;
                for (let i = 0, j = outerPoints.length - 1; i < outerPoints.length; j = i++) {
                    const xi = outerPoints[i][0];
                    const yi = outerPoints[i][1];
                    const xj = outerPoints[j][0];
                    const yj = outerPoints[j][1];
                    
                    if (((yi > dy) !== (yj > dy)) && (dx < (xj - xi) * (dy - yi) / (yj - yi) + xi)) {
                        inside = !inside;
                    }
                }
                
                return inside;
            }
            
            // 根據擊中位置計算得分（更新為5/3/1分制）
            getHitScore(uv) {
                const x = uv.x * 256;
                const y = (1 - uv.y) * 320;
                const centerX = 128;
                const centerY = 160;
                const scale = 110 / 100;
                
                const dx = x - centerX;
                const dy = y - centerY;
                const absDx = Math.abs(dx);
                const absdy = Math.abs(dy);
                
                // 內圈（A區）- 5分
                const innerPoints = [
                    [-20*scale, -10*scale],
                    [-10*scale, -20*scale],
                    [10*scale, -20*scale],
                    [20*scale, -10*scale],
                    [20*scale, 10*scale],
                    [10*scale, 20*scale],
                    [-10*scale, 20*scale],
                    [-20*scale, 10*scale]
                ];
                
                // 檢查是否在內八角形內
                let insideInner = false;
                for (let i = 0, j = innerPoints.length - 1; i < innerPoints.length; j = i++) {
                    const xi = innerPoints[i][0];
                    const yi = innerPoints[i][1];
                    const xj = innerPoints[j][0];
                    const yj = innerPoints[j][1];
                    
                    if (((yi > dy) !== (yj > dy)) && (dx < (xj - xi) * (dy - yi) / (yj - yi) + xi)) {
                        insideInner = !insideInner;
                    }
                }
                
                if (insideInner) return 5;
                
                // 中圈（C區）- 3分
                const midPoints = [
                    [-35*scale, -15*scale],
                    [-15*scale, -35*scale],
                    [15*scale, -35*scale],
                    [35*scale, -15*scale],
                    [35*scale, 15*scale],
                    [15*scale, 35*scale],
                    [-15*scale, 35*scale],
                    [-35*scale, 15*scale]
                ];
                
                let insideMid = false;
                for (let i = 0, j = midPoints.length - 1; i < midPoints.length; j = i++) {
                    const xi = midPoints[i][0];
                    const yi = midPoints[i][1];
                    const xj = midPoints[j][0];
                    const yj = midPoints[j][1];
                    
                    if (((yi > dy) !== (yj > dy)) && (dx < (xj - xi) * (dy - yi) / (yj - yi) + xi)) {
                        insideMid = !insideMid;
                    }
                }
                
                if (insideMid) return 3;
                
                // 外圈（D區）- 1分
                return 1;
            }
            
            initControls() {
                // 點擊射擊（新增：準備階段禁止射擊）
                this.renderer.domElement.addEventListener('click', (e) => {
                    if (this.gameStarted && !this.gameEnded && !this.isMoving && !this.isPreparing) {
                        this.shoot(e);
                    }
                });
                
                // 行動端觸控射擊（新增：準備階段禁止射擊）
                this.renderer.domElement.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (this.gameStarted && !this.gameEnded && !this.isMoving && !this.isPreparing) {
                        this.shoot(e.changedTouches[0]);
                    }
                });
            }
            
            initEventListeners() {
                // 鍵盤控制 - 左右箭頭鍵切換區域（新增：準備階段禁止移動）
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    
                    // 空白鍵或右箭頭前進到下一個區域
                    if ((e.code === 'Space' || e.code === 'ArrowRight') && this.gameStarted && !this.gameEnded && !this.isMoving && !this.isPreparing) {
                        e.preventDefault();
                        this.moveToNextZone();
                    }
                    
                    // 左箭頭回到上一個區域
                    if (e.code === 'ArrowLeft' && this.gameStarted && !this.gameEnded && !this.isMoving && !this.isPreparing) {
                        e.preventDefault();
                        this.moveToPreviousZone();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // 滑鼠移動控制
                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.mouseX += e.movementX * 0.0012;
                        this.mouseY += e.movementY * 0.0012;
                        this.mouseY = Math.max(-Math.PI/2.2, Math.min(Math.PI/2.2, this.mouseY));
                    }
                });
                
                // 行動端觸控移動
                let touchStartX = 0;
                let touchStartY = 0;
                
                this.renderer.domElement.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                    }
                });
                
                this.renderer.domElement.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (e.touches.length === 1 && this.gameStarted) {
                        const deltaX = e.touches[0].clientX - touchStartX;
                        const deltaY = e.touches[0].clientY - touchStartY;
                        
                        this.mouseX += deltaX * 0.003;
                        this.mouseY += deltaY * 0.003;
                        this.mouseY = Math.max(-Math.PI/2.2, Math.min(Math.PI/2.2, this.mouseY));
                        
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                    }
                });
                
                // UI按鈕
                document.getElementById('startBtn').addEventListener('click', () => this.startGame());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetGame());
                
                // 視窗大小調整
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            // -------------- 核心修改2：重寫startGame方法，實現音頻+延遲計時 --------------
            startGame() {
                // 避免重複點擊
                if (this.gameStarted || this.isPreparing) return;
                
                this.isPreparing = true; // 標記為準備階段
                this.gameEnded = false;
                this.score = 0;
                this.hits = 0;
                this.playerPosition = 'A';
                this.setPlayerPosition('A');
                
                // 重置靶位
                this.targets.forEach(target => {
                    target.hit = false;
                    target.plate.material.color.setHex(target.originalColor);
                });
                
                // 更新UI：顯示準備狀態
                document.getElementById('startBtn').textContent = '準備中...';
                document.getElementById('startBtn').disabled = true;
                document.getElementById('hits').textContent = `0/10`;
                
                // 1. 顯示"準備就緒"提示文字
                const readyNotice = document.createElement('div');
                readyNotice.className = 'ready-notice';
                readyNotice.textContent = '準備就緒！';
                document.body.appendChild(readyNotice);
                
                // 2. 播放"are you ready"音頻
                this.audioReady.play().catch(error => {
                    console.warn('準備音頻播放失敗：', error);
                    // 音頻播放失敗仍繼續流程（避免卡住）
                    console.warn('將跳過音頻，直接進入倒計時');
                });
                
                // 3. 3秒後執行：播放beep+開始計時
                setTimeout(() => {
                    // 播放提示音
                    this.audioBeep.play().catch(error => {
                        console.warn('提示音播放失敗：', error);
                    });
                    
                    // 開始計時
                    this.gameStarted = true;
                    this.isPreparing = false; // 結束準備階段
                    this.startTime = Date.now();
                    
                    // 更新UI：顯示遊戲中狀態
                    document.getElementById('startBtn').textContent = '遊戲中...';
                    
                    // 移除準備提示文字
                    if (document.body.contains(readyNotice)) {
                        document.body.removeChild(readyNotice);
                    }
                }, 3000); // 3秒延遲
            }
            
            resetGame() {
                // 重置準備階段狀態
                this.isPreparing = false;
                
                this.gameStarted = false;
                this.gameEnded = false;
                this.currentTime = 0;
                this.score = 0;
                this.hits = 0;
                this.playerPosition = 'A';
                this.setPlayerPosition('A');
                
                // 重置靶位
                this.targets.forEach(target => {
                    target.hit = false;
                    target.plate.material.color.setHex(target.originalColor);
                });
                
                // 移除可能殘留的準備提示
                const readyNotice = document.querySelector('.ready-notice');
                if (readyNotice) readyNotice.remove();
                
                // 更新UI
                document.getElementById('startBtn').textContent = '開始';
                document.getElementById('startBtn').disabled = false;
                this.updateUI();
            }
            
            // 移動到下一個區域
            moveToNextZone() {
                const zones = ['A', 'B', 'C', 'D', 'E'];
                const currentIndex = zones.indexOf(this.playerPosition);
                if (currentIndex < zones.length - 1) {
                    this.smoothMoveToPosition(zones[currentIndex + 1]);
                }
            }
            
            // 移動到上一個區域
            moveToPreviousZone() {
                const zones = ['A', 'B', 'C', 'D', 'E'];
                const currentIndex = zones.indexOf(this.playerPosition);
                if (currentIndex > 0) {
                    this.smoothMoveToPosition(zones[currentIndex - 1]);
                }
            }
            
            smoothMoveToPosition(position) {
                this.isMoving = true;
                const startPos = { x: this.camera.position.x, y: this.camera.position.y, z: this.camera.position.z };
                const targetPos = this.positions[position];
                
                // 根據不同區域設置視角目標點（靶位位置）- B區朝向140度後方
                const lookAtOffsets = {
                    A: { x: -18, y: 2.8, z: -2 },
                    B: { x: -0.25, y: 2.8, z: 10.75 },  // 朝向140度後方的靶位中心
                    C: { x: 6, y: 2.8, z: -2 },
                    D: { x: 18, y: 2.8, z: -2 },
                    E: { x: 30, y: 2.8, z: -2 }
                };
                
                const targetLookAt = lookAtOffsets[position];
                
                const startLookAt = new THREE.Vector3();
                this.camera.getWorldDirection(startLookAt);
                startLookAt.add(this.camera.position);
                
                const positionTween = new TWEEN.Tween(startPos)
                    .to(targetPos, 1800)
                    .easing(TWEEN.Easing.Quadratic.InOut)
                    .onUpdate(() => {
                        this.camera.position.set(startPos.x, startPos.y, startPos.z);
                    });
                
                const lookAtTween = new TWEEN.Tween({
                    x: startLookAt.x,
                    y: startLookAt.y,
                    z: startLookAt.z
                })
                .to(targetLookAt, 1800)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .onUpdate((obj) => {
                    this.camera.lookAt(new THREE.Vector3(obj.x, obj.y, obj.z));
                })
                .onComplete(() => {
                    this.playerPosition = position;
                    this.isMoving = false;
                    this.checkZoneCompletion();
                });
                
                positionTween.start();
                lookAtTween.start();
            }
            
            setPlayerPosition(position) {
                const pos = this.positions[position];
                this.camera.position.set(pos.x, pos.y, pos.z);
                
                // 根據不同區域設置初始視角（看向靶位）- B區朝向140度後方
                const lookAtOffsets = {
                    A: { x: -18, y: 2.8, z: -2 },
                    B: { x: -0.25, y: 2.8, z: -1.75 },  // 朝向140度後方的靶位中心
                    C: { x: 6, y: 2.8, z: -2 },
                    D: { x: 18, y: 2.8, z: -2 },
                    E: { x: 30, y: 2.8, z: -2 }
                };
                
                const targetLookAt = lookAtOffsets[position];
                this.camera.lookAt(targetLookAt.x, targetLookAt.y, targetLookAt.z);
                
                this.mouseX = 0;
                this.mouseY = 0;
            }
            
            shoot(event) {
                if (this.isMoving) return;
                
                const rect = this.renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2();
                
                if (event) {
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                } else {
                    mouse.x = 0;
                    mouse.y = 0;
                }
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);
                const intersects = raycaster.intersectObjects(this.targetMeshes);
                
                if (intersects.length > 0) {
                    const hitObject = intersects[0].object;
                    const target = this.targets.find(t => t.plate === hitObject);
                    
                    if (target && !target.hit && this.canHitTarget(target)) {
                        // 更精確的擊中偵測：檢查UV坐標是否在靶位有效區域內
                        const uv = intersects[0].uv;
                        if (this.isValidHit(uv)) {
                            target.hit = true;
                            target.plate.material.color.setHex(0xFF6B6B);
                            this.hits++;
                            
                            // 根據擊中區域給分
                            const score = this.getHitScore(uv);
                            this.score += score;
                            
                            this.showHitIndicator(score);
                            this.checkZoneCompletion();
                            
                            // 檢查是否所有目標都被擊中
                            if (this.hits === 10) {
                                this.endGame();
                            }
                        }
                    }
                }
            }
            
            // 檢查當前區域是否所有目標都已擊中
            checkZoneCompletion() {
                const currentZoneTargets = this.targets.filter(t => t.zone === this.playerPosition);
                const hitCount = currentZoneTargets.filter(t => t.hit).length;
                
                // 如果當前區域所有目標都被擊中，自動移動到下一個區域（除了最後一個區域）
                if (hitCount === currentZoneTargets.length && this.playerPosition !== 'E') {
                    setTimeout(() => {
                        this.moveToNextZone();
                    }, 500);
                }
            }
            
            canHitTarget(target) {
                // 只能擊中當前區域的目標
                return target.zone === this.playerPosition;
            }
            
            showHitIndicator(score = 1) {
                const indicator = document.createElement('div');
                indicator.className = 'hit-indicator';
                
                // 根據得分顯示不同的擊中資訊
                if (score >= 5) {
                    indicator.textContent = '+' + score;
                    indicator.style.color = '#FFD700';
                } else if (score >= 3) {
                    indicator.textContent = '+' + score;
                    indicator.style.color = '#00FF00';
                } else {
                    indicator.textContent = '+' + score;
                    indicator.style.color = '#00FF00';
                }
                
                document.body.appendChild(indicator);
                
                setTimeout(() => {
                    if (document.body.contains(indicator)) {
                        document.body.removeChild(indicator);
                    }
                }, 1000);
            }
            
            endGame() {
                this.gameEnded = true;
                const finalTime = this.currentTime;
                const bonus = Math.max(0, 20 - Math.floor(finalTime)); // 時間獎勵調整為匹配新計分
                this.score += bonus;
                
                setTimeout(() => {
                    this.showCustomAlert(`遊戲結束！\n時間: ${finalTime.toFixed(2)}秒\n總分: ${this.score}分`, () => {
                        document.getElementById('startBtn').textContent = '再玩一次';
                        document.getElementById('startBtn').disabled = false;
                    });
                }, 500);
            }
            
            showCustomAlert(message, callback) {
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                modal.innerHTML = `
                    <div class="bg-white dark:bg-gray-800 p-8 rounded-lg shadow-lg max-w-sm w-full mx-4 text-center">
                        <h3 class="text-xl font-bold text-gray-800 dark:text-white mb-4">恭喜！</h3>
                        <p class="text-gray-700 dark:text-gray-300 mb-6 whitespace-pre-line">${message}</p>
                        <button class="px-6 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded font-semibold">確定</button>
                    </div>
                `;
                document.body.appendChild(modal);
                
                modal.querySelector('button').onclick = () => {
                    document.body.removeChild(modal);
                    callback();
                };
            }
            
            updateMovement() {
                TWEEN.update();
            }
            
            updateUI() {
                document.getElementById('timer').textContent = this.currentTime.toFixed(2) + 's';
                document.getElementById('score').textContent = this.score;
                document.getElementById('hits').textContent = `${this.hits}/10`;
                document.getElementById('position').textContent = this.playerPosition;
            }
            
            gameLoop() {
                if (this.gameStarted && !this.gameEnded) {
                    this.currentTime = (Date.now() - this.startTime) / 1000;
                }
                
                this.updateMovement();
                this.updateUI();
                this.renderer.render(this.scene, this.camera);
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // 深色模式支援
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });
        
        // 啟動遊戲
        new IPSC3DGame();
    </script>
</body>
</html>